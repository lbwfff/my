####主要还是为了节省劳动力吧

案例一：
  n1= c('gene_up','gene_down','gene_diff')
  n2= c('BP','MF','CC') 
for (i in 1:3){
    for (j in 1:3){
      fn=paste0(pro, '_dotplot_',n1[i],'_',n2[j],'.pdf')
      cat(paste0(fn,'\n'))
      pdf(fn,width = 8,height = 6)
      print( dotplot(go_enrich_results[[i]][[j]],color = "pvalue")+
               scale_y_discrete(labels = function(x) str_wrap(x, width = 45)))
      dev.off()
    }
  }

这种用法在linux上也用到过，for (i in ""){},感觉比较能理解

案例二：

test_kegg <- function(gene_up,pro='shTRA2A-shNC'){
  gene_up=unique(gene_up)
  kk.up <- enrichKEGG(gene         = gene_up,
                      organism     = 'hsa',
                      pvalueCutoff = 0.9,
                      qvalueCutoff =0.9)
  head(kk.up)[,1:6]
  kk=kk.up
  pdf(file = paste0(pro,'test.kegg.up.pdf'),width=8,height = 6)
  print(dotplot(kk,color = "pvalue")+
    scale_y_discrete(labels = function(x) str_wrap(x, width = 45)))
  dev.off()
  kk=DOSE::setReadable(kk, OrgDb='org.Hs.eg.db', keyType='ENTREZID')
  write.csv(kk@result,paste0(pro,'kegg.up.csv'))
}

test_kegg(gene_up,pro = 'ipe')

##试了一下，可以运行，暂时先体会这两种方法，可以减少非常多的无效代码


实战一：
list<-c('Abcam','CST','SYSY')
for (i in list){
  path1<-paste0("~/biodata/merip/exomepeak2/",i,"-1/Mod.bed")
  path2<-paste0("~/biodata/merip/exomepeak2/",i,"-2/Mod.bed")
gr1 <- toGRanges(path1, format="BED", header=FALSE) 
gr2 <- toGRanges(path2, format="BED", header=FALSE) 

peaks <- GRangesList(rep1=gr1,
                     rep2=gr2)
pdf(file = paste0(i,'genomicElementDistribution.pdf'),width=6,height = 4)
genomicElementDistribution(peaks, 
                           TxDb = TxDb,
                           promoterRegion = c(upstream = 2000, downstream = 100),
                           geneDownstream = c(upstream = 0, downstream = 1000),
                           labels = list(geneLevel = c(promoter = "Promoter", geneDownstream = "Downstream",geneBody = "Gene body", distalIntergenic = "Distal Intergenic"), 
                                         ExonIntron = c(exon= "Exon", intron = "Intron", intergenic = "Intergenic"), 
                                         Exons = c(utr5 = "5' UTR",utr3 = "3' UTR", CDS = "CDS", otherExon = "Other exon"), 
                                         group = c(geneLevel ="Gene Level", promoterLevel = "Promoter Level", Exons = "Exon level", ExonIntron ="Exon/Intron/Intergenic")),
                           labelColors = c(promoter = "#D55E00", geneDownstream = "#E69F00", geneBody ="#51C6E6", 
                                           distalIntergenic = "#AAAAAA", exon = "#009DDA", intron = "#666666",
                                           intergenic = "#DDDDDD", utr5 = "#0072B2", utr3 = "#56B4E9", CDS = "#0033BF",
                                           otherExon = "#009E73")
)
dev.off()
}

#######apply循环的使用#######
#######这种循环对于你操作矩阵至关重要！######

f<-function(x) sum(x > 0 & !is.na(x))
apply(fc,1,f)####1为行，2为列，此处计算fc矩阵中每一行大于零且不为na的值的数目

#######进阶实例########
######使用poolr包的stouffer函数对p矩阵的每一行进行p值的合并######
######此例可以让你更好的理解apply循环，function的x是是什么？如果想把function应用在apply上，此处的x应该是行（或列）#####
library('poolr')
f<-function(x) stouffer(as.numeric(x[!is.na(as.numeric(unlist(x)))]))$p
allgene$integrateP<-apply(p,1,f)

#####判断句#####
#####基本的使用方法是，ifelse(对象,yes,no)######
#####此处的应用是，对于diff矩阵，如果v1，v2同时为0或同时为翻译，则输出‘no change’，若不则进行下一步的判断。在下一步的判断中，若v1为0，v2为翻译，则输出‘turn-on’，否则输出‘turn-off’########
#####需要解释的是此处的0原先为na，但是我发现如果用na进行判断则会使逻辑变得更加复杂，所以将na改为了0进行简化######
diff$change = ifelse((diff$V1==0 & diff$V2==0)|(diff$V1=='translating' & diff$V2=='translating'),'no change',ifelse(diff$V1==0 & diff$V2=='translating','turn-on','turn-off'))

