####主要还是为了节省劳动力吧

案例一：
  n1= c('gene_up','gene_down','gene_diff')
  n2= c('BP','MF','CC') 
for (i in 1:3){
    for (j in 1:3){
      fn=paste0(pro, '_dotplot_',n1[i],'_',n2[j],'.pdf')
      cat(paste0(fn,'\n'))
      pdf(fn,width = 8,height = 6)
      print( dotplot(go_enrich_results[[i]][[j]],color = "pvalue")+
               scale_y_discrete(labels = function(x) str_wrap(x, width = 45)))
      dev.off()
    }
  }

这种用法在linux上也用到过，for (i in ""){},感觉比较能理解

案例二：

test_kegg <- function(gene_up,pro='shTRA2A-shNC'){
  gene_up=unique(gene_up)
  kk.up <- enrichKEGG(gene         = gene_up,
                      organism     = 'hsa',
                      pvalueCutoff = 0.9,
                      qvalueCutoff =0.9)
  head(kk.up)[,1:6]
  kk=kk.up
  pdf(file = paste0(pro,'test.kegg.up.pdf'),width=8,height = 6)
  print(dotplot(kk,color = "pvalue")+
    scale_y_discrete(labels = function(x) str_wrap(x, width = 45)))
  dev.off()
  kk=DOSE::setReadable(kk, OrgDb='org.Hs.eg.db', keyType='ENTREZID')
  write.csv(kk@result,paste0(pro,'kegg.up.csv'))
}

test_kegg(gene_up,pro = 'ipe')

##试了一下，可以运行，暂时先体会这两种方法，可以减少非常多的无效代码


实战一：
list<-c('Abcam','CST','SYSY')
for (i in list){
  path1<-paste0("~/biodata/merip/exomepeak2/",i,"-1/Mod.bed")
  path2<-paste0("~/biodata/merip/exomepeak2/",i,"-2/Mod.bed")
gr1 <- toGRanges(path1, format="BED", header=FALSE) 
gr2 <- toGRanges(path2, format="BED", header=FALSE) 

peaks <- GRangesList(rep1=gr1,
                     rep2=gr2)
pdf(file = paste0(i,'genomicElementDistribution.pdf'),width=6,height = 4)
genomicElementDistribution(peaks, 
                           TxDb = TxDb,
                           promoterRegion = c(upstream = 2000, downstream = 100),
                           geneDownstream = c(upstream = 0, downstream = 1000),
                           labels = list(geneLevel = c(promoter = "Promoter", geneDownstream = "Downstream",geneBody = "Gene body", distalIntergenic = "Distal Intergenic"), 
                                         ExonIntron = c(exon= "Exon", intron = "Intron", intergenic = "Intergenic"), 
                                         Exons = c(utr5 = "5' UTR",utr3 = "3' UTR", CDS = "CDS", otherExon = "Other exon"), 
                                         group = c(geneLevel ="Gene Level", promoterLevel = "Promoter Level", Exons = "Exon level", ExonIntron ="Exon/Intron/Intergenic")),
                           labelColors = c(promoter = "#D55E00", geneDownstream = "#E69F00", geneBody ="#51C6E6", 
                                           distalIntergenic = "#AAAAAA", exon = "#009DDA", intron = "#666666",
                                           intergenic = "#DDDDDD", utr5 = "#0072B2", utr3 = "#56B4E9", CDS = "#0033BF",
                                           otherExon = "#009E73")
)
dev.off()
}

#######apply循环的使用#######
#######这种循环对于你操作矩阵至关重要！######

f<-function(x) sum(x > 0 & !is.na(x))
apply(fc,1,f)####1为行，2为列，此处计算fc矩阵中每一行大于零且不为na的值的数目

#######进阶实例########
######使用poolr包的stouffer函数对p矩阵的每一行进行p值的合并######
######此例可以让你更好的理解apply循环，function的x是是什么？如果想把function应用在apply上，此处的x应该是行（或列）#####
library('poolr')
f<-function(x) stouffer(as.numeric(x[!is.na(as.numeric(unlist(x)))]))$p
allgene$integrateP<-apply(p,1,f)

######解决了你一直想解决的一些问题######
f <-function(x) unlist(strsplit(x$experiment_title,';'))[1]
plate <-apply(list2,1,f) 
#####这是错误示范，会显示报错：$ operator is invalid for atomic vectors,具体的原理我不是太懂，但是通过像下面的改动可以避开这个问题####
f <-function(x) unlist(strsplit(x['experiment_title'],';'))[1]
list2$plate <-apply(list2,1,f)
####这样就可以取得任意封号前的字符了，换成'_',或者其他什么也可以操作，解决了一个大麻烦#####

#####判断句#####
#####基本的使用方法是，ifelse(对象,yes,no)######
#####此处的应用是，对于diff矩阵，如果v1，v2同时为0或同时为翻译，则输出‘no change’，若不则进行下一步的判断。在下一步的判断中，若v1为0，v2为翻译，则输出‘turn-on’，否则输出‘turn-off’########
#####需要解释的是此处的0原先为na，但是我发现如果用na进行判断则会使逻辑变得更加复杂，所以将na改为了0进行简化######
diff$change = ifelse((diff$V1==0 & diff$V2==0)|(diff$V1=='translating' & diff$V2=='translating'),'no change',ifelse(diff$V1==0 & diff$V2=='translating','turn-on','turn-off'))

########我一直想写一个自动画图的function，以下为第一次尝试##########
plot <- function(data,gene,group,label_1){
  data2<-as.data.frame(t(data[gene,]))
  colnames(data2)<-c('exp')
  data2$group<-group
  data2$group<- factor(data2$group,levels = c("normal", "tumor"))
  library(ggsignif)
  library(ggsci)
  library(ggpubr)
  ptext<-paste0("t.test, p=",compare_means(exp~group,data2,method = "t.test")[[5]])
  dat_text <- data.frame(label = ptext)
  dat_text[1,1]<-c(paste0(dat_text[1,1],'\n Tumor N=157 \n Paratumor N=157'))
  colors<-c('#36537155', "#96345A74")
  
  dp <- ggplot(data2, aes(x=group, y=exp,fill=group))+
    geom_violin(aes(colour=group),fill='#DDDDDD50',trim=FALSE,show.legend=FALSE,size=0.7)+
    geom_jitter(aes(fill=group),width =0.2,shape = 21,size=4,colour='NA',alpha = 0.4)+
    geom_boxplot(fill='white',width=0.12,,outlier.shape = NA,size=0.8)+
    labs(y="log2(FPKM)")
  path<-c(paste0(gene,'.pdf'))
  pdf(path,width = 8,height = 7)
  print(dp + theme_classic(base_size = 22)+ 
    scale_colour_manual(values=c(colors))+
    scale_fill_manual(values=c(colors))+
    theme(legend.position = "none")+
    theme(axis.text=element_text(size=18),axis.title=element_text(size=22))+
    annotate('text',x=0.8,y=label_1,label=dat_text,colour = "black",size=6))
  dev.off()}

plot(data = exp,gene = 'ENSG00000123009.4_120282483_120282716_77',group = group_list,label_1 =1.4)
#改了一下，我觉得好歹算个半自动画图函数，主要在文本的地方改了一下，现在不要老去调两个文本的位置了，方便了很多。针对不同的矩阵，还是需要调整许多地方，但是这种程度的调整的话，都还能接受吧。



