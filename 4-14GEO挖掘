#一次诡异的GEO挖掘过程，我真是个copy鬼才

library(GEOquery)
gset <- getGEO('GSE102558', destdir=".")
names(Meta(gset))
Table(gset)[1:5,1:5]

rm(list = ls())
a=read.table('GSE102558_series_matrix.txt.gz',
             sep = '\t',quote="",fill=T,
             comment.char = "!",header=T)#,header=T
rownames(a)<-a[,1]#每一列当成每行的行名，填2就是第二列
a<-a[,-1]

gpl <- getGEO('GPL20710', destdir=".")
colnames(Table(gpl))
head(Table(gpl)[,c(1,2,3,12)])
write.csv(Table(gpl)[,c(1,3)],"GPL20710.csv")
b=read.table('GPL20710.csv',header = T,sep = ',')
rownames(b)<-b[,1]
b<-b[,-1]


ids=b
save(ids,a, file='input.Rdata')#将ids，a，pdata数据集合输出为input.Rdate,如果我没猜错的话，

exprSet=a
table(rownames(exprSet) %in% ids$ID)
ids=ids[ids$ID %in% rownames(exprSet),]
dim(ids)
exprSet=exprSet[rownames(exprSet) %in% ids$ID,]
dim(exprSet)

ids=ids[match(rownames(exprSet),ids$ID),]
head(ids)
exprSet[1:5,1:5]              

expr<-cbind(ids$Symbol,exprSet)
write.csv(expr,"expr.csv")

dat<-read.table('expr.csv',sep = ",",header = T)
dat<-dat[,-1]

dat$median=apply(dat,1,median) #ids新建median这一列，列名为median，同时对dat这个矩阵按行操作，取每一行的中位数，将结果给到median这一列的每一行
dat=dat[order(dat$gene,dat$median,decreasing = T),]#对ids$symbol按照ids$median中位数从大到小排列的顺序排序，将对应的行赋值为一个新的ids
dat=dat[!duplicated(dat$gene),]

rownames(dat)<-dat[,1]#每一列当成每行的行名，填2就是第二列
dat<-dat[,-1]
dat<-dat[,-25]

exprSet=dat
boxplot(exprSet[,1])#对第一列基因的表达作了图

group_list<-c("MCAO-24","MCAO-24","MCAO-24","MCAO-24","MCAO-24","MCAO-24","MCAO-72","MCAO-72","MCAO-72","MCAO-72","MCAO-72","MCAO-72","sham-24","sham-24","sham-24","sham-24","sham-24","sham-24","sham-72","sham-72","sham-72","sham-72","sham-72","sham-72")
group_list=as.factor(group_list)

library(reshape2)
exprSet<-as.matrix(exprSet)#又把数据框转成了矩阵，因为之后melt函数对数据框运行的话会少一列
exprSet_L=melt(exprSet)
colnames(exprSet_L)=c('gene','sample','value')
exprSet_L$group=rep(group_list,each=nrow(exprSet))#添加了group列
head(exprSet_L)

library(ggplot2)
p=ggplot(exprSet_L,
         aes(x=sample,y=value,fill=group))+geom_boxplot()
print(p)#利用exprSet_L来作图，先是每个sample的箱图
p=ggplot(exprSet_L,aes(x=sample,y=value,fill=group))+geom_violin()
print(p)#小提琴图
p=ggplot(exprSet_L,aes(value,fill=group))+geom_histogram(bins = 200)+facet_wrap(~sample, nrow = 4)
print(p)#分面图？还是什么东西
p=ggplot(exprSet_L,aes(value,col=group))+geom_density()+facet_wrap(~sample, nrow = 4)
print(p)#和上图类似的一个图形
p=ggplot(exprSet_L,aes(value,col=group))+geom_density() 
print(p)#密度图？
p=ggplot(exprSet_L,aes(x=sample,y=value,fill=group))+geom_boxplot()
p=p+stat_summary(fun.y="mean",geom="point",shape=23,size=3,fill="red")
p=p+theme_set(theme_set(theme_bw(base_size=20)))
p=p+theme(text=element_text(face='bold'),axis.text.x=element_text(angle=30,hjust=1),axis.title=element_blank())
print(p)

g_mean <- tail(sort(apply(exprSet,1,mean)),50)
g_median <- tail(sort(apply(exprSet,1,median)),50)
g_max <- tail(sort(apply(exprSet,1,max)),50)
g_min <- tail(sort(apply(exprSet,1,min)),50)
g_sd <- tail(sort(apply(exprSet,1,sd)),50)
g_var <- tail(sort(apply(exprSet,1,var)),50)
g_mad <- tail(sort(apply(exprSet,1,mad)),50)
g_mad
names(g_mad)#完全没懂

library(pheatmap)
choose_gene=names(tail(sort(apply(exprSet,1,mad)),50))#上个单元筛选了一些基因，在这用到了exprSet,1,mad,能这样理解吗？
choose_matrix=exprSet[choose_gene,]
choose_matrix=t(scale(t(choose_matrix)))
pheatmap(choose_matrix)

library(UpSetR)
g_all <- unique(c(names(g_mean),names(g_median),names(g_max),names(g_min),
                  names(g_sd),names(g_var),names(g_mad) ))
dat=data.frame(g_all=g_all,
               g_mean=ifelse(g_all %in%  names(g_mean) ,1,0),
               g_median=ifelse(g_all %in%  names(g_median) ,1,0),
               g_max=ifelse(g_all %in%  names(g_max) ,1,0),
               g_min=ifelse(g_all %in%  names(g_min) ,1,0),
               g_sd=ifelse(g_all %in%  names(g_sd) ,1,0),
               g_var=ifelse(g_all %in%  names(g_var) ,1,0),
               g_mad=ifelse(g_all %in%  names(g_mad) ,1,0)
)
upset(dat,nsets = 7)

group_list
dim(exprSet)
exprSet[1:5,1:5]

colnames(exprSet)=paste(group_list,1:24,sep='')
nodePar <- list(lab.cex = 0.6, pch = c(NA, 19), 
                cex = 0.7, col = "blue")
hc=hclust(dist(t(exprSet)))
par(mar=c(5,5,5,10)) 
plot(as.dendrogram(hc), nodePar = nodePar,  horiz = TRUE)

library(ggfortify)
df=as.data.frame(t(exprSet))
df$group=group_list 
autoplot(prcomp( df[,1:(ncol(df)-1)] ), data=df,colour = 'group')

library("FactoMineR")#画主成分分析图需要加载这两个包
library("factoextra") 
df=as.data.frame(t(exprSet))
dat.pca <- PCA(df, graph = FALSE)#现在dat最后一列是group_list，需要重新赋值给一个dat.pca,这个矩阵是不含有分组信息的
fviz_pca_ind(dat.pca,
             geom.ind = "point", # show points only (nbut not "text")
             col.ind = group_list, # color by groups
             # palette = c("#00AFBB", "#E7B800"),
             addEllipses = TRUE, # Concentration ellipses
             legend.title = "Groups"
)

group_list=as.factor(group_list)#4-13，t检验的时候加了这么一行才跑出来的
group_list
dat = exprSet
group1 = which(group_list == levels(group_list)[1])
group2 = which(group_list == levels(group_list)[2])
group3 = which(group_list == levels(group_list)[3])
group4 = which(group_list == levels(group_list)[4])
dat1 = dat[, group1]
dat2 = dat[, group2]
dat3 = dat[, group3]
dat4 = dat[, group4]
dat = cbind(dat1,dat3)
ngroup_list<-c("MACO24","MACO24","MACO24","MACO24","MACO24","MACO24","sham24","sham24","sham24","sham24","sham24","sham24")#差异表达，我发现下面的函数只能对两组数据进行差异表达，所以这里只分析了yong组的MCAO/SHAM

pvals = apply(dat, 1, function(x){
  t.test(as.numeric(x)~ngroup_list)$p.value
})
p.adj = p.adjust(pvals, method = "BH")
avg_1 = rowMeans(dat1)
avg_3 = rowMeans(dat3)
log2FC = avg_1-avg_3
DEG_t.test = cbind(avg_1, avg_3, log2FC, pvals, p.adj)
DEG_t.test=DEG_t.test[order(DEG_t.test[,4]),]
DEG_t.test=as.data.frame(DEG_t.test)
head(DEG_t.test)

suppressMessages(library(limma)) 
design <- model.matrix(~0+factor(ngroup_list))
colnames(design)=levels(factor(ngroup_list))
rownames(design)=colnames(dat)
design

contrast.matrix<-makeContrasts(paste0(unique(ngroup_list),collapse = "-"),levels = design)
contrast.matrix 

fit <- lmFit(dat,design)
##step2
fit2 <- contrasts.fit(fit, contrast.matrix) #这一步很重要，可以自行看看效果
fit2 <- eBayes(fit2)  #default no trend !!!
##eBayes() with trend=TRUE
##step3
tempOutput = topTable(fit2, coef=1, n=Inf)
nrDEG = na.omit(tempOutput) 
#write.csv(nrDEG2,"limma_notrend.results.csv",quote = F)
head(nrDEG)

write.table(nrDEG,"nrDEG.csv",sep=",")#不知道为什么就空了一行，不过影响倒是不大
DEG=nrDEG
logFC_cutoff <- with(DEG,mean(abs( logFC)) + 2*sd(abs( logFC)) )
DEG$change = as.factor(ifelse(DEG$P.Value < 0.05 & abs(DEG$logFC) > logFC_cutoff,
                              ifelse(DEG$logFC > logFC_cutoff ,'UP','DOWN'),'NOT')
)
this_tile <- paste0('Cutoff for logFC is ',round(logFC_cutoff,3),
                    '\nThe number of up gene is ',nrow(DEG[DEG$change =='UP',]) ,
                    '\nThe number of down gene is ',nrow(DEG[DEG$change =='DOWN',])
)
this_tile
head(DEG)
g = ggplot(data=DEG, aes(x=logFC, y=-log10(P.Value), color=change)) +
  geom_point(alpha=0.4, size=1.75) +
  theme_set(theme_set(theme_bw(base_size=20)))+
  xlab("log2 fold change") + ylab("-log10 p-value") +
  ggtitle( this_tile  ) + theme(plot.title = element_text(size=15,hjust = 0.5))+
  scale_colour_manual(values = c('blue','black','red'))  ## corresponding to the levels(res$change)
print(g)#这边出了一个很鬼畜的火山图，因为这次跑的数据本身就很诡异，我应该看看文献作者具体是怎样处理的数据

## heatmap 
library(pheatmap)
choose_gene=head(rownames(nrDEG),25)
choose_matrix=exprSet[choose_gene,]
choose_matrix=t(scale(t(choose_matrix)))
pheatmap(choose_matrix)

Dat=DEG
write.csv(Dat,"Dat.csv")
Dat<-read.table("Dat.csv",sep = ",",header = T)


library(ggplot2)
library(ggrepel)
Dat$threshold = factor(ifelse(Dat$P.Value < 0.05 & abs(Dat$logFC) >= 1, ifelse(Dat$logFC>= 1 ,'Up','Down'),'NoSignifi'),levels=c('Up','Down','NoSignifi'))
ggplot(Dat,aes(x=logFC,y=-log10(P.Value),color=threshold))+
  geom_point()+
  scale_color_manual(values=c("#DC143C","#00008B","#808080"))+#确定点的颜色
  geom_text_repel(
    data = Dat[Dat$P.Value<0.05&abs(Dat$logFC)>1,],
    aes(label = X),
    size = 3,
    segment.color = "black", show.legend = FALSE )+#添加关注的点的基因名
  theme_bw()+#修改图片背景
  theme(
    legend.title = element_blank()#不显示图例标题
  )+
  ylab('-log10 (P.Value)')+#修改y轴名称
  xlab('logFC')+#修改x轴名称
  geom_vline(xintercept=c(-1,1),lty=3,col="black",lwd=0.5) +#添加横线|FoldChange|>2
  geom_hline(yintercept = -log10(0.05),lty=3,col="black",lwd=0.5)


###4-15诡异的kegg
exprSet<-read.table("expr.csv",header = T,sep = ",")
exprSet<-exprSet[,-1]

library("clusterProfiler")
library(org.Mm.eg.db)
exprSet.df <- bitr(exprSet$gene, fromType = "SYMBOL", #fromType是指你的数据ID类型是属于哪一类的
                toType = c("ENSEMBL"), #R是指你要转换成哪种ID类型，可以写多种，也可以只写一种
                OrgDb = org.Mm.eg.db)#Orgdb是指对应的注释包是哪个
head(exprSet.df)

a=exprSet
table(a$gene %in% exprSet.df$SYMBOL)
a=a[a$gene %in% exprSet.df$SYMBOL,]
dim(a)
exprSet.df=exprSet.df[exprSet.df$SYMBOL %in% a$gene,]
dim(exprSet.df)
b=exprSet.df[!duplicated(exprSet.df$SYMBOL), ]

identical(b$SYMBOL,a$gene)
c=cbind(b$ENSEMBL,a)
fix(c)
c<-c[,-2]
c=c[!duplicated(c$ENSEMBL), ]
rownames(c)=c$ENSEMBL
c<-c[,-1]

group_list<-c("MCAO-24","MCAO-24","MCAO-24","MCAO-24","MCAO-24","MCAO-24","MCAO-72","MCAO-72","MCAO-72","MCAO-72","MCAO-72","MCAO-72","sham-24","sham-24","sham-24","sham-24","sham-24","sham-24","sham-72","sham-72","sham-72","sham-72","sham-72","sham-72")
group_list=as.factor(group_list)

dat = c
group1 = which(group_list == levels(group_list)[1])
group2 = which(group_list == levels(group_list)[2])
group3 = which(group_list == levels(group_list)[3])
group4 = which(group_list == levels(group_list)[4])
dat1 = dat[, group1]
dat2 = dat[, group2]
dat3 = dat[, group3]
dat4 = dat[, group4]
dat = cbind(dat1,dat3)
ngroup_list<-c("MACO24","MACO24","MACO24","MACO24","MACO24","MACO24","sham24","sham24","sham24","sham24","sham24","sham24")#差异表达，我发现下面的函数只能对两组数据进行差异表达，所以这里只分析了yong组的MCAO/SHAM

pvals = apply(dat, 1, function(x){
  t.test(as.numeric(x)~ngroup_list)$p.value
})
p.adj = p.adjust(pvals, method = "BH")
avg_1 = rowMeans(dat1)
avg_3 = rowMeans(dat3)
log2FC = avg_1-avg_3
DEG_t.test = cbind(avg_1, avg_3, log2FC, pvals, p.adj)
DEG_t.test=DEG_t.test[order(DEG_t.test[,4]),]
DEG_t.test=as.data.frame(DEG_t.test)
head(DEG_t.test)

suppressMessages(library(limma)) 
design <- model.matrix(~0+factor(ngroup_list))
colnames(design)=levels(factor(ngroup_list))
rownames(design)=colnames(dat)
design

contrast.matrix<-makeContrasts(paste0(unique(ngroup_list),collapse = "-"),levels = design)
contrast.matrix 

fit <- lmFit(dat,design)
##step2
fit2 <- contrasts.fit(fit, contrast.matrix) #这一步很重要，可以自行看看效果
fit2 <- eBayes(fit2)  #default no trend !!!
##eBayes() with trend=TRUE
##step3
tempOutput = topTable(fit2, coef=1, n=Inf)
nrDEG = na.omit(tempOutput) 
#write.csv(nrDEG2,"limma_notrend.results.csv",quote = F)
head(nrDEG)

write.table(nrDEG,"nrDEG.csv",sep=",")#不知道为什么就空了一行，不过影响倒是不大
DEG=nrDEG
logFC_cutoff <- with(DEG,mean(abs( logFC)) + 2*sd(abs( logFC)) )
DEG$change = as.factor(ifelse(DEG$P.Value < 0.05 & abs(DEG$logFC) > logFC_cutoff,
                              ifelse(DEG$logFC > logFC_cutoff ,'UP','DOWN'),'NOT')
)
this_tile <- paste0('Cutoff for logFC is ',round(logFC_cutoff,3),
                    '\nThe number of up gene is ',nrow(DEG[DEG$change =='UP',]) ,
                    '\nThe number of down gene is ',nrow(DEG[DEG$change =='DOWN',])
)
this_tile
head(DEG)

up<-DEG[DEG$change=="UP",]
down<-DEG[DEG$change=="DOWN",]
up=row.names(up)
down=row.names(down)
deg<-list(up=up,down=down)
fix(deg)

library(ggplot2)
library(clusterProfiler)
library(org.Mm.eg.db)
gene_up= bitr(unique(deg$up), fromType = "ENSEMBL",
              toType = c( "ENTREZID"),
              OrgDb = org.Mm.eg.db)[,2] 

gene_down= bitr(unique(deg$down), fromType = "ENSEMBL",
                toType = c( "ENTREZID"),
                OrgDb = org.Mm.eg.db)[,2] 
gene_diff=c(gene_up,gene_down)

source('kegg_and_go_up_and_down.R')
# 同样的，里面包装了一些代码，比如setReadable函数
# 很有可能你使用的时候就发现过期了里面有一些参数
# 要学会调试代码，不要畏手畏脚。
run_kegg(gene_up,gene_down,pro='rna_test')
# 需要多go数据库的3个条目进行3次富集分析，非常耗时。
run_go(gene_up,gene_down,pro='rna_test')
# 很多绘图代码，都是依据数据本身特性需要调整的，而且高阶情况下需要AI等等。
go <- enrichGO(gene_up, OrgDb = "org.Mm.eg.db", ont="all") 
barplot(go, split="ONTOLOGY")+ facet_grid(ONTOLOGY~., scale="free") 
ggsave('gene_up_GO_all_barplot.png',width = 9, height = 6)
go <- enrichGO(gene_down, OrgDb = "org.Mm.eg.db", ont="all") 
barplot(go, split="ONTOLOGY",font.size =10)+ 
  facet_grid(ONTOLOGY~., scale="free") + 
  scale_x_discrete(labels=function(x) str_wrap(x, width=50))+
  ggsave('gene_down_GO_all_barplot.png',width = 9, height = 6)
