age<- c(1,3,5,7,9,2,6,8,9,3)#创造值age
weight<- c(4,5,6,7,5,6,7,8,4,5)#创造值weight
mean(weight)#值weight的平均值
sd(weight)#标准差
cor(age,weight)#线性关系
plot(age,weight)#出了散点图
q()#退出了R

getwd() #当前工作目录，setwd则可以设定工作目录

help(package="ggplot2")

help.start()
install.packages("vcd")
help(package="vcd")
library(vcd)
help(Arthritis)
example(Arthritis)

y<- matrix(22:41,nrow = 5,ncol = 4)#2:21就从2数到21，5行，4列

cells<-c(6,26,24,68)#矩阵中的数值有这么四个
rnames<-c("R1","R2")#行名
cnames<-c("C1","C2")#列名
mymatrix<-matrix(cells,nrow = 2,ncol = 2,byrow = TRUE,
                 dimnames=list(rnames,cnames))#按行填充数值

mymatrix<-matrix(cells,nrow = 2,ncol = 2,byrow = FALSE,
                 dimnames=list(rnames,cnames))#按列填充

ID<-c(1,3,5,6)
age<-c(32,45,12,45)
dia<-c(1,2,2,1)
s<-c(T,F,T,T)
data<-data.frame(ID,age,dia,s)#创建一个所谓的数据框

data[1:2]#检视data的1至2列
data[c("age","age")]#可以检视你打进去的列
data$age#$号可以选取一个给定数据框中的某个特定变量
table(data$ID,data$dia)#data数据框中的ID和dia做了一个表格

summary(mtcars$mpg)#就输出了mtcars数据中mpg一列的的最大值，最小值，平均数什么的
plot(mtcars$cyl,mtcars$drat)
#plot(cyl,drat)，如果这样写是跑不出来的

attach(mtcars)
plot(cyl,drat)
detach(mtcars)#但是这样就可以，虽然好像并没有多方便

mpg<-c(25,36,47)
attach(mtcars)

data<-data.frame(ID,s,age,dia,row.names = ID)#把ID，s，age，dia，四组值组成一个数据框，行名为ID

patientID<-c(1,2,3,4)
age<-c(25,34,28,52)
status<-c("typel1","typel2","typel1","typel1")
diabets<-c("poor","improved","excellent","poor")
diabets<-factor(diabets)
status<-factor(status,order = TRUE)
patientdata<-data.frame(patientID,age,diabets,status)
str(patientdata)#显示对象结构
summary(patientdata)#显示对象统计概要

#从带分隔符的文本文件导入数据，使用read.table()，header是一个表明首行是否包含了变量名的逻辑值（TRUE或FALSE），sep用来指定分隔数据的分隔符，row.names是一个可选参数，用以指定一个或多个表示行标识符的变量。
#示例如：grades<-read.table("XXX.scv",header=TRUE,sep=",",row.name="YYY")
#指从工作目录读入一个名为XXX.csv的逗号分隔文件，从第一行取得各变量名称，将变量YYY指定为行标识符，最后将结果保存到了grade数据框中。
#参数sep允许你导入那些使用逗号以外的符号来分隔行内数据的文件。你可以使用sep="\t"读取以制表符分隔的文件。此参数的默认值为sep=""，即表示分隔符可为一个或多个空格、制表符、换行符或回车符。
#设置选项stringsAsFactors=FALSE，这将停止对所有字符型变量的此种转换。另一种方法是使用选项colClasses为每一列指定一个类。微调数据导入方式的追加选项在help(read.table)

library(RODBC)
channel<-odbcConnectExcel(demo.xlsx)
mydataframe<-sqlFetch(channel,"sheet1")
odbcClose(channel)#这边odbcConnectExcel只能用在32位windows上，但是这一串代码其实也没有那么有意义

demo<-read.table("demo.csv")#这样跑出来就一列
demo<-read.table("demo.csv",sep = ",")#分隔开来了
demo<-read.table("demo.csv",sep=",",header =TRUE )#第一行成了列名
demo<-read.table("demo.csv",sep=",",header =TRUE,row.names="X" )#第一列成了行名

#summary(demo$A2M)
#mean(demo$A2M)#这两个简单函数跑行是跑不出来的，只能对于列来做分析？
summary(demo$TCGA.06.5408.01)
mean(demo$TCGA.27.1830.01)
plot(demo$TCGA.06.2557.01,demo$TCGA.27.1830.01)#这图有统计学意义？

length(demo)#显示元素的数量，例如demo中有123个sample，则输出123
dim(demo)#显示维度，简单讲就是多少行多少列
str(demo)#显示结构
str(demo$TCGA.27.1830.01)#这样写也是可以出结果的
class(demo)#数据的类别，demo是数据框就输出data.frame
class(demo$TCGA.27.1830.01)#输出integer，整数？
mode(demo)#对象的模式,输出list
mode(demo$TCGA.27.1830.01)#输出numeric
names(demo)#各个成分的名称，这边把123个sample名全给出来了
new<-c(status,newobject)#合并为一个向量，暂时还不知道有什么用
ww<-cbind(demo$X,demo$TCGA.27.1830.01,demo$TCGA.06.5408.01)#但这没有基因名啊
zz<-rbind(demo$TCGA.27.1830.01,demo$TCGA.06.5408.01)#横着输出可还行，因为暂时不知道怎么选定数据框中行排，所以这个函数暂时对我可能没那么有用
demo
head(demo)#输出开始几行
tail(demo)#输出最后几行
ls()#显示当前Global Enviroment中有几个对象
rm(age)#删除对象
rm(demo$TCGA.27.1830.01)#这样会报错，可是为什么呢
newobject<-edit(diabets)#对对象进行编辑并输出为新对象
fix(ww)#居然可以这样编辑，这可太方便了吧
